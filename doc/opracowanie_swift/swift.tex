\input{../header.tex}

\hypersetup{
	unicode = true,
	pdfauthor = {Jakub Kotur},
}

\title{OpenStack Storage (Swift)}
\author{Jakub Kotur}

\hyphenation{IaaS Rack-Space}

\begin{document}
\maketitle

\section{Wstęp}

\nocite{openstack}

OpenStack Storage, inaczej nazywany Swift, jest systemem chmurowym pozwalającym na przechowywanie danych. Długo obiekty które są przechowywane przez system miały ograniczenie wielkości 5GB, jednak niedawno twórcom udało się z nim poradzić. Swift Pozwala on na przechowywanie płaskiej struktury obiektów (plików), grupowanych w kontenerach. Każdy użytkownik może posiadać dowolnie dużo kontenerów, a w nich dowolnie dużo plików. W zależności od konfiguracji system pozwala na tworzenie kopii zapasowych, oraz automatyczne zarządzanie tymi kopiami. API systemu oparte jest na prostych wywołaniach PUT, GET i paru innych.

%\section{Możliwości}\label{sec:możliwości}

%\section{Zastosowania}\label{sec:zastosowania}

\section{Architektura}\label{sec:architektura}

System posiada szereg jednostek z których każda odpowiedzialna jest za konkretne zadanie. Jednostką taką może być zarówno serwer, proces jak i struktura danych, opisujące działanie systemu. W poniższym rozdziale zostaną pokrótce przedstawione wszystkie jednostki. Dokładny opis wybranych jednostek znajduje się w późniejszych rozdziałach.

\subsection{Główne komponenty}\label{sub:glowne komponenty}

\subsubsection{Serwery}\label{sub:serwery}

\begin{description}
\item[Serwer proxy] -- serwer odpowiedzialny za kontrolę nad innymi serwerami chmury. Do niego wysyłane są zapytanie API, które następnie kieruje do odpowiednich serwerów. Jest również odpowiedzialny za kontrolę błędów, np. jeśli okaże się że wywołany serwer jest niedostępny, to właśnie serwer proxy znajduje jego serwer lustrzany i wysyła nowe zapytanie.
\item[Serwer obiektów] -- prosty serwer przechowujący pliki jako dane binarne. Dodatkowe metadane o plikach przechowywane są w rozszerzonych atrybutach plików. W zależności od ustawień może być replikowany, tak że kilka serwerów przechowuje takie same dane.
\item[Serwer kontenerów] -- bardzo podobny do serwera obiektów, jednak przechowujący informacje o tym co znajduje się wa danym kontenerze. Dane przechowywane są w bazie sqlite jako szereg wpisów z nazwami obiektów. Analogicznie do serwera obiektów można tworzyć repliki tych serwerów.
\item[Serwer kont] -- identyczny z serwerem kontenerów, tylko przechowuje dane o kontenerach które posiada dane konto.
\end{description}

\subsubsection{Procesy}\label{sub:procesy}

Aby zapewnić spójność i aktualność danych w całym systemie, ciągle chodzą w nim trzy procesy. Wszystkie trzy są odpowiedzialne za to zadanie, jednak uaktywniają się w różnych sytuacjach.

\begin{description}
\item[Aktualizatory] -- proces dbający o to, aby aktualizować dane na serwerach. Jeśli z jakiegoś powodu aktualizacja danych do serwera nie zostanie wysłana, albo przez serwer odebrana, zostaje ona zakolejkowana. Po z góry ustalonym czasie próba aktualizacji jest ponawiana.
\item[Audytory] -- proces sprawdzający spójność danych w chmurze. Jeśli napotka zepsuty plik, stara się go naprawić używając repliki. Jeśli jest to niemożliwe, błąd jest logowany. 
\item[Replikatory] -- również dbają o spójność danych, jednak ich zadaniem jest utrzymywanie jednakowej wersji na wszystkich serwerach. Jeśli któryś z serwerów nie ma najnowszej wersji, jego dane aktualizowane są do niej.
\item[Żniwiar] -- albo ładniej, żniwiarz użytkowników, jest procesem który dba o usuwanie danych, które należały do użytkowników usuniętych z systemu. Jeśli uda mu się usunąć wszystkie pliki, oraz kontenery użytkownika, kasuje tego użytkownika z bazy.
\end{description}

\subsubsection{Struktury danych}\label{sub:struktury danych}

\begin{description}
\item[Pierścień] -- zestaw mapowań z kluczy obiektów OpenStacka na fizyczne urządzenia. Dzięki pierścieniowi serwer proxy wie do którego serwera obiektów wysłać zapytanie. Istnieją oddzielne pierścienie dla obiektów, kontenerów i kont, jednak są one identyczne. W pierścieniu można ustawić poziom replikacji serwerów.
\item[Urządzenie] -- lokalizacja fizycznego dysku w chmurze z dodatkowymi danymi na jego temat. Na podstawie danych zawartych w opisie urządzenia pierścień zna dokładne miejsce gdzie ma zostać wysłane zapytanie, oraz może dynamicznie wybierać lepsze, bądź po prostu aktualnie aktywne urządzenia.
\end{description}

\subsection{Przykładowa konfiguracja}\label{sub:przykladowa konfiguracja}

Na rysunku \hyperref[fig:swift_arch]{rysunku \ref{fig:swift_arch}} została przedstawiona najprostsza konfiguracja chmury Swifta. Serwer autoryzacji, oraz serwer proxy muszą być dostępne dla użytkowników, aby mogli oni wysyłać zapytania do chmury. Użytkownik najpierw odpytuje serwer autoryzacji o swój token, następnie cała komunikacja odbywa się za pośrednictwem serwera proxy. Serwery opisane na obrazku jako storage, mogą być serwerami kont, kontenerów lub obiektów, lub wszystkimi naraz. Ich połączenie jest już dowolne.

\begin{figure}
\centering
	\includegraphics[width=0.75\textwidth]{swift_install_arch.png}
	\caption{Przykladowa architektura swifta~\cite{swift_manual}}
\label{fig:swift_arch}
\end{figure}


\subsection{Replikacja}\label{sec:replikacja}

Replikacja w Swifcie podzielona jest na dwa moduły. Jeden odpowiada za replikację obiektów (danych), drugi za replikację kontenerów i kont, czyli po efektywnie baz danych. Oba moduły jednak polegają na zasadzie PUSH, czyli każdy serwer dba o to, aby jego dane lokalne jeśli są nowe, znalazły się na wszystkich replikach. Wysyłanie odbywa się poprzez pierścień, który decyduje które serwery są faktycznie replikami danego serwera. Mechanizm ten wygląda w ten sposób, ponieważ serwer nie wie skąd pobrać dane, a więc i gdzie są nowsze dane niż te które posiada. Warto jeszcze wspomnieć o mechanizmie usuwania danych z chmury, ponieważ jest on nieoczywisty. 

Trzeba zaznaczyć że prace nad modułem replikacji w Swifcie są aktualnie podczas tworzenia, więc większość informacji zawartej w tym rozdziale może się niedługo zmienić, bądź już jest nieaktualna. Niemniej ogólna idea zapewne pozostanie taka sama.

\subsubsection{Bazy danych}\label{sub:bazy danych}

W pierwszej kolejności serwery baz danych porównują hasze baz, jeśli się zgadzają, synchronizacja nie jest potrzebna. W przeciwnym przypadku synchronizowane są brakujące rekordy.

Serwery baz danych przechowują dodatkową bazę synchronizacji. W takiej bazie istnieje informacja, kiedy ostatnio serwer był synchronizowany z którymi bazami. Bazy rozpoznawane są po unikalnych w skali replikacji identyfikatorach. Jeżeli zdalna baza jest starsza, nowe rekordy są wysyłane. Po wysłaniu wszystkich rekordów cała baza synchronizacji wysyłana jest na zdalny serwer. W ten sposób informacja o synchronizacji z innymi bazami, przechodzi na serwer zdalny.

\subsubsection{Obiekty}\label{sub:obiekty}

Na serwerach obiektów również trzymane są hasze dla każdego katalogu z danymi. Jeżeli hasze się różnią, dane z danego katalogu są synchronizowane przy pomocy rsynca. Po takiej operacji nowe hasze są wyliczane na zdalnej maszynie.

\subsubsection{Usuwanie}\label{sub:usuwanie}

Kiedy z serwera obiektów usuwany jest plik, zamiast usunięcia go, stawiany jest specjalny plik, będący znacznikiem usunięcia. Taki plik ma ten sam identyfikator co poprzednie dane, jednak ma nowszą wersję. Dzięki temu proces odpowiedzialny za integralność danych w chmurze rozpropaguje taki znacznik po wszystkich replikach. Znacznik jest usuwany po czasie zwanym oknem spójności, czyli po czasie po którym jesteśmy pewni że dany plik został rozpowszechniony na wszystkie serwery.

\subsection{Autoryzacja}\label{sec:autoryzacja}

Ponieważ autoryzacja w swifcie maja historyczne zaszłości i jest mocno związana z innymi systemami Rackspace'a, można ją przeprowadzać na kilka sposobów. Może być prowadzona poprzez zupełnie oddzielny system niezależny od swifta, bądź przez podsystem swifta nazywany Swauth. Ogólna koncepcja autoryzacji w systemie opiera się na tokenie autoryzacji, który dołączany jest do każdego żądania wysyłanego przez użytkownika. Token taki jest po prostu stringiem. Z punktu widzenia swifta ważne jest jedynie aby móc go wysłać do systemu autoryzacji i otrzymać odpowiedź, czy token jest poprawny czy nie. Jeśli odpowiedź jest pozytywna, wraz z nią przychodzi informacja o czasie wygaśnięcia autoryzacji w sekundach. Przez ten czas swift przetrzymuje token jako poprawny. Autoryzacja jest pierwszą czynnością którą musi wykonać użytkownik systemu. Po zalogowaniu się w serwerze autoryzacyjnym, dostanie on token, który musi być dołączony do każdego zapytania.

Wbudowany w swifta system autoryzacji Swauth pozwala dodatkowo na konta administracyjne. Kiedy normalni użytkownicy ograniczeni są do własnych kontenerów, administratorzy mogą operować na danych w całym systemie.

\subsection{Segmentacja}\label{sec:segmentacja}

Jak zostało już wcześniej wspomniane OpenStack miał swojego czasu ograniczenie na wielkość jednego pliku wynoszącą 5GB. Aktualnie ograniczenie to zostało zniesione, jednak ograniczenie na wielkość jednego pliku pozostaje i jest konfigurowalne. Domyślnie cały czas jest to 5GB. Aby poradzić sobie z tym ograniczeniem twórcy OpenStacka wprowadzili ideę segmentacji obiektów. Jeden plik dla użytkownika, może być przechowywany w chmurze jako dowolna ilość segmentów. Aby poradzić sobie z segmentacją, wraz z segmentami do Swifta wysyłany jest specjalny plik manifestu w którym przechowywane są informacje w którym kontenerze i z jakim prefiksem przechowywane są segmenty. Wszystkie segmenty muszą być przechowywane w tym samym kontenerze, jednak plik manifestu może być w innym. Dzięki temu obiekty segmentów nie zaśmiecają listingu bazowego kontenera, a plik manifestu udaje normalny obiekt.

Dodatkową korzyścią płynącą z segmentacji jest współbieżne wysyłanie pliku przez serwery. Jeżeli np. segmenty zostaną rozprowadzone po różnych centrach danych, użytkownik może pobierać duży plik z prędkością sumaryczną oferowaną przez te serwerownie.

\section{Konfiguracja}\label{sec:konfiguracja}

Swift używa do konfiguracji zewnętrznej biblioteki pythona Paste Deploy~\cite{paste_deploy}, który implementuje standard WSGI odnośnie konfiguracji serwerów. Dokładny opis składni plików konfiguracyjnych znajduje się w dokumentacji tejże biblioteki pod adresem \url{http://pythonpaste.org/deploy/#the-config-file}. 

Konfiguracja każdego serwera znajduje się w pliku \texttt{/etc/swift/<server-name>-server.conf}, gdzie nazwą serwera może być object, container bądź account, w zależności który serwer chcemy skonfigurować. W tych plikach znajdują się wszystkie opcje konfiguracyjne serwerów w formacie wspomnianym powyżej. Dokładny spis wszystkich opcji znajduje się pod adresem \url{http://swift.openstack.org/deployment_guide.html#general-server-configuration}.

Dodatkowo jeśli chcemy skonfigurować serwer obiektów, musimy w nim zdefiniować które dyski będą używane do przechowywania danych. W parametrze \texttt{devices} ustawiamy katalog w którym chcemy przechowywać dane. W tym katalogu tworzymy foldery i w każdym folderze montujemy jedną partycje. Dobrą praktyką jest nadawanie katalogom nazw urządzeń systemowych.

\section{Instalacja}\label{sec:instalacja}

Dokładny opis instalacji Swifta, dedykowany dla programistów, dobrze opisany jest w dokumentacji~\cite{swift_doc}. Po wykonaniu instrukcji zawartych w tym opisie otrzymujemy działające środowisko programistyczne na jednej maszynie, symulującej chmurę złożoną z czterech serwerów.

Jeśli chcemy skonfigurować kilka maszyn, na każdej z nich trzeba zainstalować Swifta, a pliki konfiguracyjne odpowiednio rozproszyć. 

Opis ten jest dostępny pod adresem: \url{http://swift.openstack.org/development_saio.html}

\bibliographystyle{../plplainurl}
\bibliography{../bibliografia}
	
\end{document}
